# -*- coding: utf-8 -*-
"""
@author: 
% _____________________________________________________
Main paper:
Yang, X. S. (2010). "A New Metaheuristic Bat-Inspired Algorithm, 
in: Nature Inspired Cooperative Strategies for Optimization (NISCO 2010)". 
Studies in Computational Intelligence. 284: 65â€“74. 
"""
import random
import numpy
import math
import time

#This class is for data collection, not important
class solution:
    def __init__(self):
        self.best = 0
        self.bestIndividual = []
        self.convergence = []
        self.optimizer = ""
        self.objfname = ""
        self.startTime = 0
        self.endTime = 0
        self.executionTime = 0
        self.lb = 0
        self.ub = 0
        self.dim = 0
        self.popnum = 0
        self.maxiers = 0

#Main alg function!!!
def BAT(objf, lb, ub, dim, N, Max_iteration, min_Q=0, max_Q=2, Amp=0.5, rate=0.5, alpha=1, gamma=float("nan")):

    n = N
    # Population size

    if not isinstance(lb, list):
        lb = [lb] * dim
    if not isinstance(ub, list):
        ub = [ub] * dim
    N_gen = Max_iteration  # Number of generations

    A = Amp #0.5
    # Loudness  (constant or decreasing)
    r = rate #0.5
    # Pulse rate (constant or decreasing)

    Qmin = min_Q #0  # Frequency minimum
    Qmax = max_Q #2  # Frequency maximum

    d = dim  # Number of dimensions

    # Initializing arrays
    Q = numpy.zeros(n)  # Frequency
    v = numpy.zeros((n, d))  # Velocities
    Convergence_curve = []
    
    # Initialize the population/solutions
    Sol = numpy.zeros((n, d))
    for i in range(dim):
        Sol[:, i] = numpy.random.rand(n) * (ub[i] - lb[i]) + lb[i]

    S = numpy.zeros((n, d))
    S = numpy.copy(Sol)
    Fitness = numpy.zeros(n)

    # initialize solution for the final results
    s = solution()
    print('BAT is optimizing  "' + objf.__name__ + '"')

    # Initialize timer for the experiment
    timerStart = time.time()
    s.startTime = time.strftime("%Y-%m-%d-%H-%M-%S")

    # Evaluate initial random solutions
    for i in range(0, n):
        #print(Sol[i, :])
        Fitness[i] = objf(Sol[i, :])

    # Find the initial best solution and minimum fitness
    I = numpy.argmin(Fitness)
    best = Sol[I, :]
    fmin = min(Fitness)

    # Main loop
    for t in range(0, N_gen):

        # Loop over all bats(solutions)
        for i in range(0, n):
            Q[i] = Qmin + (Qmin - Qmax) * random.random()
            v[i, :] = v[i, :] + (Sol[i, :] - best) * Q[i]
            S[i, :] = Sol[i, :] + v[i, :]

            # Check boundaries
            for j in range(d):
                Sol[i, j] = numpy.clip(Sol[i, j], lb[j], ub[j])

            # Pulse rate
            if random.random() > r:
                S[i, :] = best + 0.001 * numpy.random.randn(d)

            # Evaluate new solutions
            Fnew = objf(S[i, :])

            # Update if the solution improves
            if (Fnew <= Fitness[i]) and (random.random() < A):
                Sol[i, :] = numpy.copy(S[i, :])
                Fitness[i] = Fnew
                A = alpha*A
                if not math.isnan(gamma):
                    r = rate*(1-math.exp(-gamma*t))

            # Update the current best solution
            if Fnew <= fmin:
                best = numpy.copy(S[i, :])
                fmin = Fnew
                

        # update convergence curve
        Convergence_curve.append(fmin)

        #if t % 1 == 0:
            #print(["At iteration " + str(t) + " the best fitness is " + str(fmin)])

    timerEnd = time.time()
    s.endTime = time.strftime("%Y-%m-%d-%H-%M-%S")
    s.executionTime = timerEnd - timerStart
    s.convergence = Convergence_curve
    s.optimizer = "BAT"
    s.objfname = objf.__name__
    s.best = best

    return s
